#Centroid Initialization Methods

#As k-means clustering aims to converge on an optimal set of cluster centers (centroids) 
#and cluster membership based on distance from these centroids via successive iterations, 
#it is intuitive that the more optimal the positioning of these initial centroids, the fewer 
#iterations of the k-means clustering algorithms will be required for convergence. This suggests 
#that some strategic consideration to the initialization of these initial centroids could prove useful.

#What methods of centroid initialization exist? While there are a number of initialization strategies, let's focus on the following:

# Centroid Initialization Methods
from sklearn import datasets
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs
import numpy as np
from sklearn.metrics import pairwise_distances_argmin
import matplotlib.animation as animation
from PIL import Image  # Correct import for Pillow
from IPython.display import display

# Generate synthetic data
X, y = make_blobs(n_samples=500, centers=3, cluster_std=1.0, random_state=42)

# Plot the true clusters
plt.figure(figsize=(8, 6))
plt.scatter(X[:, 0], X[:, 1], c=y, cmap='rainbow', s=50)
plt.title("True Clusters (Generated by make_blobs)")
plt.xlabel("Feature 1")
plt.ylabel("Feature 2")
plt.show()

def animate_kmeans(centroids_history, labels, title, filename):
    fig, ax = plt.subplots(figsize=(8, 6))
    scat = ax.scatter(X[:, 0], X[:, 1], c=labels, cmap='rainbow', s=50)
    centroids_plot, = ax.plot([], [], 'kx', markersize=10, markeredgewidth=2)

    ax.set_xlim(np.min(X[:, 0]) - 1, np.max(X[:, 0]) + 1)
    ax.set_ylim(np.min(X[:, 1]) - 1, np.max(X[:, 1]) + 1)
    ax.set_title(title)

    def update(i):
        centroids = centroids_history[i]
        centroids_plot.set_data(centroids[:, 0], centroids[:, 1])
        return scat, centroids_plot

    ani = animation.FuncAnimation(fig, update, frames=len(centroids_history), interval=500, repeat=False)

    # Save the animation as a GIF
    ani.save(filename, writer='imagemagick', fps=1)
    plt.close()

def display_gif(filename):
    img = Image.open(filename)  # Use Image.open() to load the GIF
    img.show()  # Display the GIF (optional, works in most environments)
    return img

# K-means with random initialization
random_state = 42
n_clusters = 3
max_iter = 10
np.random.seed(random_state)

centroids = X[np.random.choice(X.shape[0], n_clusters, replace=False)]
centroids_history = [centroids.copy()]

for i in range(max_iter):
    labels = pairwise_distances_argmin(X, centroids)
    new_centroids = np.array([X[labels == j].mean(axis=0) for j in range(n_clusters)])
    centroids_history.append(new_centroids)
    if np.all(centroids == new_centroids):
        break
    centroids = new_centroids

# Generate and display the GIF
animate_kmeans(centroids_history, labels, title="K-means with Random Initialization", filename="random_init.gif")
display_gif("random_init.gif")  # Call the corrected function

#K-means++
#K-means++ is an improved initialization algorithm that addresses the limitations of random initialization. 
#It ensures that centroids are chosen in a more strategic way:
#The first centroid is chosen randomly from the data points.
#For each remaining centroid, data points that are farther away from existing centroids are more likely to be selected.
#Specifically, each point is chosen with a probability proportional to its distance from the nearest centroid.
#This method ensures that the initial centroids are spread out, leading to:
#Faster convergence: The algorithm requires fewer iterations to converge.
#Better clustering quality: The algorithm is less likely to get stuck in local minima, resulting in more optimal clusters.

centroids = [X[np.random.choice(X.shape[0])]]
for _ in range(1, n_clusters):
    distances = np.min([np.linalg.norm(X - c, axis=1) for c in centroids], axis=0)
    probs = distances / distances.sum()
    next_centroid = X[np.random.choice(X.shape[0], p=probs)]
    centroids.append(next_centroid)

centroids = np.array(centroids)
centroids_history = [centroids.copy()]

for i in range(max_iter):
    labels = pairwise_distances_argmin(X, centroids)
    new_centroids = np.array([X[labels == j].mean(axis=0) for j in range(n_clusters)])
    centroids_history.append(new_centroids)
    if np.all(centroids == new_centroids):
        break
    centroids = new_centroids


animate_kmeans(centroids_history, labels, title="K-means with K-means++ Initialization", filename="kmeanspp_init.gif")

print("K-means++ Initialization Animation:")
display(display_gif("kmeanspp_init.gif"))